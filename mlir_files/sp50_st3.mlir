// Sparse-Dense Matrix Multiplication using CSR
#CSR = #sparse_tensor.encoding<{ 
   map = (d0, d1) -> (d0: compressed, d1: dense) 
}>

module {
    func.func @matmul(%t : tensor<10x10xf64, #CSR>, %s : tensor<10x10xf64>, %out : tensor<10x10xf64>)
        -> tensor<10x10xf64> {
        %0 = linalg.matmul
            ins(%t, %s: tensor<10x10xf64, #CSR>, tensor<10x10xf64>)
            outs(%out: tensor<10x10xf64>) -> tensor<10x10xf64>
        return %0 : tensor<10x10xf64>
    }

    func.func @main() -> i64 {
        %c = tensor.empty() : tensor<10x10xf64>
        %t_sparse = call @assemble_sparse() : () -> tensor<10x10xf64, #CSR>
        %s = arith.constant dense<[
            [[9.612462, 7.452880, 8.345066, 7.457379, 1.647867, 3.322601, 8.777239, 7.456120, 0.525232, 6.762113], [4.594322, 9.447205, 8.511697, 5.906654, 3.246121, 8.539829, 9.803566, 5.755030, 7.378573, 1.171255], [7.522250, 8.652618, 6.127642, 9.475041, 1.879694, 0.727529, 3.144871, 4.558722, 4.937764, 9.654446], [9.981583, 2.836741, 7.499942, 5.899090, 6.094037, 4.598650, 0.555066, 7.904553, 7.104836, 6.344735], [8.376112, 9.177526, 0.576967, 7.494532, 0.423076, 1.923263, 1.749647, 9.405374, 6.167835, 9.473528], [1.134587, 3.417198, 0.676097, 9.222314, 7.873789, 7.181745, 8.786623, 4.730127, 0.094103, 1.014003], [5.429215, 3.734023, 2.875604, 9.427055, 1.461336, 0.878401, 5.692947, 8.364215, 8.662924, 3.751155], [6.266580, 7.970202, 9.088518, 0.886204, 3.857730, 5.500128, 2.023344, 8.792418, 2.815916, 6.387384], [9.362063, 1.453763, 8.931132, 1.519808, 2.594294, 9.218295, 2.438485, 5.908859, 9.469429, 6.538062], [9.695551, 7.607667, 5.264475, 9.861434, 8.762580, 0.791307, 7.492576, 3.330117, 9.858134, 7.169951]]
        ]> : tensor<10x10xf64>
        %result_matrix = call @matmul(%t_sparse, %s, %c) :
            (tensor<10x10xf64, #CSR>, tensor<10x10xf64>, tensor<10x10xf64>) -> tensor<10x10xf64>
        %c1 = arith.constant 1 : index

        %element_f64 = tensor.extract %result_matrix[%c1, %c1] : tensor<10x10xf64>
        %element_i64 = arith.fptosi %element_f64 : f64 to i64
        return %element_i64 : i64
    }

    func.func @assemble_sparse() -> tensor<10x10xf64, #CSR> {
        %values = arith.constant dense<[4.782065, 5.011190, 5.104059, 7.448233, 1.551192, 6.781608, 7.816378, 1.408111, 2.320379, 4.876145, 5.432362, 4.925237, 1.968668, 1.474827, 6.494381, 9.657962, 4.670517, 5.879595, 0.484486, 7.101864, 7.107571, 9.808629, 9.052142, 4.515495, 9.446657, 0.863892, 5.811668, 9.647429, 6.339252, 0.619713, 2.738375, 7.880850, 6.790901, 3.290592, 6.510183, 9.580808, 1.358977, 2.057244, 3.206749, 1.925688, 0.859536, 4.323037, 2.619395, 7.868058, 4.768883, 7.654949, 3.550460, 5.175182, 8.276439, 3.833934]> : tensor<50xf64>
        %row_ptr = arith.constant dense<[0, 5, 9, 16, 24, 29, 32, 38, 41, 43, 50]> : tensor<11xindex>
        %col_ind = arith.constant dense<[0, 3, 6, 8, 9, 1, 4, 6, 8, 0, 1, 3, 4, 5, 7, 8, 0, 1, 2, 3, 4, 6, 7, 9, 1, 3, 4, 5, 9, 0, 1, 6, 0, 3, 4, 6, 8, 9, 0, 3, 4, 3, 4, 0, 3, 4, 5, 6, 7, 9]> : tensor<50xindex>
        %s = sparse_tensor.assemble(%row_ptr, %col_ind), %values : (tensor<11xindex>, tensor<50xindex>), tensor<50xf64> to tensor<10x10xf64, #CSR>
        return %s : tensor<10x10xf64, #CSR>
    }
    
}
