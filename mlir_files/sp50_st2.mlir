// Sparse-Dense Matrix Multiplication using CSR
#CSR = #sparse_tensor.encoding<{ 
   map = (d0, d1) -> (d0: compressed, d1: dense) 
}>

module {
    func.func @matmul(%t : tensor<10x10xf64, #CSR>, %s : tensor<10x10xf64>, %out : tensor<10x10xf64>)
        -> tensor<10x10xf64> {
        %0 = linalg.matmul
            ins(%t, %s: tensor<10x10xf64, #CSR>, tensor<10x10xf64>)
            outs(%out: tensor<10x10xf64>) -> tensor<10x10xf64>
        return %0 : tensor<10x10xf64>
    }

    func.func @main() -> i64 {
        %c = tensor.empty() : tensor<10x10xf64>
        %t_sparse = call @assemble_sparse() : () -> tensor<10x10xf64, #CSR>
        %s = arith.constant dense<[
            [[8.028024, 3.382677, 3.912771, 6.955871, 9.927971, 8.807170, 9.829161, 4.778355, 6.982979, 6.418485], [2.876747, 8.827915, 2.857120, 7.864993, 1.481254, 5.863107, 1.902524, 0.287128, 8.201994, 8.051296], [2.573433, 1.428706, 6.253611, 9.429610, 1.100220, 7.591420, 6.063684, 9.628597, 9.127321, 9.971268], [1.276599, 3.225634, 3.783044, 4.988013, 4.260299, 3.101554, 1.878471, 1.833516, 1.949327, 2.126631], [7.195140, 3.910971, 2.741396, 3.803917, 8.543509, 1.907745, 4.026888, 8.401561, 8.938171, 7.346852], [1.302439, 4.147854, 3.191971, 6.280916, 4.868285, 2.495486, 6.847467, 5.836947, 2.186727, 6.211686], [8.210264, 0.962694, 8.571297, 0.895042, 5.246813, 3.984959, 1.653111, 4.956738, 0.097860, 9.869258], [8.781656, 2.344153, 1.205614, 0.707313, 0.413978, 8.810310, 0.646430, 2.543223, 4.494127, 3.814817], [8.757179, 0.413951, 4.558870, 8.441631, 7.504324, 2.083326, 3.597896, 6.457458, 7.914710, 2.886757], [7.977659, 5.582956, 2.216315, 5.265742, 7.808415, 1.828531, 1.558669, 4.686119, 3.882357, 8.599102]]
        ]> : tensor<10x10xf64>
        %result_matrix = call @matmul(%t_sparse, %s, %c) :
            (tensor<10x10xf64, #CSR>, tensor<10x10xf64>, tensor<10x10xf64>) -> tensor<10x10xf64>
        %c1 = arith.constant 1 : index

        %element_f64 = tensor.extract %result_matrix[%c1, %c1] : tensor<10x10xf64>
        %element_i64 = arith.fptosi %element_f64 : f64 to i64
        return %element_i64 : i64
    }

    func.func @assemble_sparse() -> tensor<10x10xf64, #CSR> {
        %values = arith.constant dense<[5.545327, 3.084653, 3.163502, 8.748984, 7.233332, 7.925297, 0.818479, 8.779213, 6.774204, 2.186480, 4.978609, 7.540125, 3.594497, 9.061533, 5.098416, 1.159961, 3.624217, 1.247756, 3.593193, 3.733966, 3.665587, 7.184449, 9.552943, 7.716935, 9.119021, 5.675380, 4.165772, 2.152147, 7.959322, 1.124688, 3.536788, 1.892431, 7.920527, 3.910954, 6.041134, 4.856939, 5.698733, 4.846652, 2.151234, 0.546019, 9.842581, 1.533519, 7.176477, 9.432196, 5.287737, 3.875192, 8.194025, 8.369721, 2.692556, 1.816040]> : tensor<50xf64>
        %row_ptr = arith.constant dense<[0, 5, 9, 15, 20, 27, 31, 36, 40, 46, 50]> : tensor<11xindex>
        %col_ind = arith.constant dense<[0, 2, 4, 6, 8, 1, 3, 5, 9, 0, 2, 4, 6, 7, 8, 1, 2, 3, 6, 8, 0, 2, 3, 4, 6, 8, 9, 1, 2, 5, 9, 0, 2, 4, 6, 8, 0, 1, 2, 3, 0, 2, 4, 6, 7, 8, 0, 3, 4, 8]> : tensor<50xindex>
        %s = sparse_tensor.assemble(%row_ptr, %col_ind), %values : (tensor<11xindex>, tensor<50xindex>), tensor<50xf64> to tensor<10x10xf64, #CSR>
        return %s : tensor<10x10xf64, #CSR>
    }
    
}
